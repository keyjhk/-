# 数组

## 二分查找

适用条件：有序、元素非重复。如果元素重复的话，二分查找到的索引是不唯一的。

二分法思想简单，**但最重要的是确定区间的定义，这样子才可以在循环里保持区间不变。**

以下假设数组非递减。

```python
'''
区间定义为 左闭右开 
右端点是取不到的，所以一开始取值为len
当middle比较过以后 right直接定义为middle 而left定义为左端点+1 （因为它可以取到）
'''
def search(nums,target):
    left,right=0,len(nums)
    while left<right:
        middle=(left+right)//2
        if nums[middle]==target:
            return middle
        elif nums[middle]>target:
            right=middle
        else:
            left=middle+1  
```

当循环结束时，left 和 right的位置有什么意义吗？ 

在上述`[left,right)` 左闭右开的区间定义下，但凡left、right有移动过，都得基于这样一个事实，

1. `left-1 < target`，因为`mid < target` 才会进行left指针的移动 
2. `right > target`，因为`mid > tatget` 才会进行right指针的移动 

可以举例观察，就是循环结束的前一步，必定是 `X ? Y`，两个指针都停留在?所在的地方。？左边的X满足`X<target`，右边的`Y>target`，而`?`要么归属左边，要么右边。

* 如果`?>target`，则right-1，仍然满足上述事实 
* 如果`?<target`，则left+1，同样满足上述事实 

所以，当循环结束时，在不断向左靠近的过程中，**right停留的位置，必定是第一个比target大的值**，这个技巧可以用于返回第一个大于等于它的值。**而left在不断向右靠近的过程中，`left-1` 也逐渐接近target，但是始终小于target.**



基于上述结结论，二分查找的思想也可以用于查找一个值的左右边界，**或者第一个大于等于它的值**。只要稍微修改它的区间变化条件即可

```python
'''
假设要寻找第一个大于等于target的值 
大于的时候条件和原来一样，关键是改变找到等于的时候，区间同样应该往左缩进
当循环结束的时候  right停留的位置元素>=target 
'''
def search(nums,target):
    left,right=0,len(nums)
    lboard=-1
    while left<right:
        middle=(left+right)//2
        if nums[middle]>=target:
            # return middle  # 等于的时候原来条件要修改为以下条件 
            right=middle # 等于的时候，往左区间找 ，因为要找第一个大于等于的值
            lboard=right # 所以区间左缩 
        else:
            left=middle+1  
    return lborard 
```



## 快慢指针

* 两个指针的作用
* 最长连续子数组的数学技巧：元素非负数，后面元素的边界一定是大于等于前面元素的边界的，类似公共前缀 



滑动窗格属于快慢指针的一种，左右指针分别控制窗格的移动。它有以下注意事项：

1. 后面元素的右边界大于等于前面元素的右边界，这样子，在左边界收缩的时候，窗格的右边界才可以固定 
2. 窗口满足判定时，才进行左边界的收缩 

```python
for right in raneg(len(nums)):
    sums += nums[right]
    # 滑动窗格的核心 
    while sums >= target:  # 当窗口满足条件时进行如下判断 
        sum -= nums[left]
        left += 1  # 移动左边界
```



# 链表

* 增加虚拟节点可以使链表的操作变得统一。如果没有虚拟节点的话，就要考虑头结点是否为空。





# 二叉树

* 遍历
  * 递归遍历
  * 非递归遍历：
    * 借助栈来模拟递归过程，保存遍历过的节点。
    * 和递归不同的是，出栈的时候进行数据处理
    * 操作分为两步：访问 和 处理。每次我们拿到的都是根节点（中间节点），我们是否要处理该节点
    * 前序遍历：根节点出栈，右节点入栈，左节点再入栈（这样才能先出）
    * 后序遍历：前序遍历调换左右孩子入栈顺序，得到中右左的访问顺序，最后反转数组 
    * 中序遍历：一路向左访问子节点，同时入栈保存，为空出栈（为空说明走到底了，左子树遍历完毕），再访问该节点的右节点

* 层次遍历 
  * 递归的思想：每层递归添加
  * 迭代：队列，一层层扫描 





## 递归三部曲

1. 递归返回值和参数
2. 递归边界确定 
3. 单层的递归逻辑



递归边界的确定，一定会基于当前节点判断，毋庸置疑

```python
if node is None: return 
```

在不包含返回值的递归中，先序中序后序的顺序比较直观，就是观察操作逻辑的顺序。

```java
void preOrder(TreeNode root){
    if(root!=null) return; // 递归边界
    ans.add(root); // 当前节点逻辑
    preOrder(root.left); // 左
    preOrder(root.right); // 右
}
```



在含返回值的递归中，递归逻辑和单层的逻辑，不自觉地就会写在一起，这时候就容易混淆遍历顺序。比如，

```java
// 236 二叉树最近公共祖先 https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // root == null 属于递归边界判断 
    // root==p || root == q 其实属于单层的递归操作逻辑 
    // 所以 这其实是 先序遍历 先处理了当前节点 再 左右子树 遍历 
    if(root == p || root == q || root == null) return root;

    TreeNode left = lowestCommonAncestor(root.left,p,q),
    right = lowestCommonAncestor(root.right,p,q);

    if(left!=null && right!=null)
        return root;
    else if (left!=null)
        return left;
    else if (right!=null)
        return right;
    else
        return null;
}
```

左右子树的递归很好区分，先左后右，只是中间节点，如注释所言，操作最先，所以上述其实是先序遍历。

那么后序遍历，应当如何呢？**将当前节点的操作逻辑放在左右子树遍历完之后，如下**。也就是说，如果要用到左右子树的遍历结果，就要选择后序遍历。

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null) return root; // 仅仅判断了递归条件 

    TreeNode left = lowestCommonAncestor(root.left,p,q),
    right = lowestCommonAncestor(root.right,p,q);

    // why root first? 
    // because root(current node) must be the ancenstor of its left/right 
    // so judge root first 
    if (root == p || root == q ) // 当前节点的操作逻辑 
        return root;
    else if(left!=null && right!=null)
        return root;
    else if (left!=null)
        return left;
    else if (right!=null)
        return right;
    else
        return null;
}
```





## 递归和回溯

递归返回的过程中，一定是包含回溯的。递归调用是入栈，递归返回就是出栈，返回的过程就是回溯。

**递归是不可能中途停止的，它不像迭代，可以借用判断continue或者break。**因此，关于回溯结果的保存，需要动一些脑筋，如下。

1. 设置统一的全局变量，单层递归逻辑时判断当下的情况，然后决定是否更改变量，或者类似操作

```python
# 递归边界

# 递归逻辑 
# 决定是否更改
```

2. **递归有返回值**，则需要借助回溯，层层向上传递。依旧借助上例的“二叉树公共祖先”

   ```java
   if(root == null) return root; 
   
   // 用left right 保存递归结果 
   TreeNode left = lowestCommonAncestor(root.left,p,q),
   right = lowestCommonAncestor(root.right,p,q);
   
   // 在当前的操作逻辑中，考虑如何抛出left right的结果 
   if (root == p || root == q ) // 当前节点的操作逻辑 
           return root;
   else if(left!=null && right!=null)
       return root;
   else if (left!=null)
       return left; // 抛出left的结果 
   else if (right!=null)
       return right; // 同理
   else
       return null;
   ```

   同时，能够发现，**递归边界的返回值 和 单层逻辑的操作返回值 可以是不同的。** 
   
   递归边界返回的意义清晰明了，就是碰到边界情况时，该如何处理。单层逻辑的操作返回值，则要考虑两个问题
   
   1.  如何处理下一层的返回值 ，可以考虑边界上一层的临界特殊情况
   2. 如何向上传递返回值，这个因逻辑而异





# 回溯

回溯常见的应用场景为组合，需要横向遍历、纵向遍历。**它的代码模板，精髓所在，正是上述的两个维度的遍历。**

回溯三部曲：

1. 递归边界，当前的组合是否达到了条件，是则返回。
2. **横向遍历，使用`for`循环，用于有序的遍历。纵向遍历使用递归， 用于问题规模的缩减。**
3. 单层逻辑中，最后回退 



以一个组合的具体问题为例，展示代码模。从数组`[1,2,3,4]` 取任意两个数，求组合总数。

```java
LinkedList<Integer> res = new LinkedList<>();  // 栈 存储当前结果集
public void backTranverse(int[] nums,int startIdx){
	// 递归边界
    if(res.size()==2){
        // 处理结果 
        System.out.println(res);
        return;
    }
    
    for(int i=startIdx;i<nums.length;i++){  // 横向遍历 
        // 单层逻辑 
        res.add(nums[i]); // 处理当前值 
        backTranverse(nums,i+1); // startIdx 偏移了 从下一个数开始 
        // 回退栈 
        res.removeLast(); 
    }
}

// 调用 起始序号为 0
backTranverse(new int[]{1,2,3,4},0); 
```



**回溯使用了递归的模式求解，如果条件允许，例如子问题之间互不影响，考虑使用记忆数组或者map结构，来记录同一问题下已经求解过的答案，避免重复计算。**

# 动态规划

动态规划问题的最大特征是存在重叠子问题，当前问题可以依赖更小规模的问题来推导解决。因此，动态规划依赖一个状态数组来进行递推。

递归问题，也有类似的特征。在解决思路上，两者有异曲同工之妙。但也稍有不同，递归在做法上，要求递归边界清晰明确，在不断递归过程中，为了避免重复计算，也往往使用map结构来记录。当问题的递归边界比较复杂时，应该考虑动态规划。



动态规划的5个步骤：

1. 确定dp数组（状态数组）以及下标的含义
2. 确定递推公式，当前状态如何依赖前序状态
3. dp数组如何初始化，考虑初始情况，可以利用递推公式检验
4. 确定遍历顺序
5. 举例推导dp数组



## 一维状态

简单的动态规划，表现形式上，也完全可以用递归来解决。例如，斐波那契、爬台阶，它们的递归边界清晰明确。

## 背包问题

背包问题分类

### 0-1背包

0-1背包，是指当前物品有且仅有1个，要么放进背包，要么不放。

#### 最大容量

假设物品有m件，背包容量为n，初始化状态数组大小`int dp[m][n]`，其中`dp[i][j]`表示在考虑物品0-i的情况下，背包容量为j能存放的最大容量（容量可以是物品价值、重量等）。

dp数组含义定义非常重要，当做如上定义时，对于位置`dp[i][j]`，可以有推导：

1. 如果当前物品i的重量大于j，背包放不下，则`dp[i][j]=dp[i-1][j]`，表示即使考虑了物品i它的最容量也等同于只考虑物品0-i-1的情况
2. 反之，物品i的重量小于j，背包能够放下。可以为了放物品i，同时不得不拿出另外一些物品，也就说物品0-i中，i是放下了，但其余物品不一定存在背包里。 **它的状态依赖于没有考虑物品i、背包容量为j-物品i重量时可以容纳的最大重量**，这是关键一步，`dp[i][j]=dp[i-1][j-weight[i]]+weighjt[i]` 

综上，`dp[i][j]=max(dp[i-1][j],dp[i-1][j-weight[i]]+weighjt[i])`，取max是因为放物品i会让另外一部分物品腾出来，不见得比不放时候的重量大。



初始化时，观察递推公式，二维数组ij状态依赖左上角。当背包容量为0时，`dp[i][0]`自然全是0，当只考虑物品0时，`dp[0][i]`在背包容量大于物品重量时，最大容量就是物品0的重量，否则为0。这样就完成了第一行第一列的初始化。 



遍历顺序：以行顺序遍历，考虑物品，或者以列顺序遍历，考虑背包容量，都是可以的。从前向后推导。



核心代码

```java
for(int i=0;i<items.length;i++){
    for(int j=0;j<=bagSize;j++){
        // if判断就是 存放与否 的动态决策 
        // max 就表示如何取舍 存放后的结果 
        if(j>=items[i]){ // 能够装下物品i
            dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]]+weight[i]);
        }else{
            dp[i][j] = dp[i-1][j];
        }
    }
}
```



二维数组的dp，在推导上更好理解，但是存在空间优化的版本，只需要一维的状态数组。那是因为dp[i]仅仅依赖上一行的数据dp[i-1]，只要想办法重复利用dp[i-1]，就可以达成目的。

问题就转为，如何在不开辟新空间的情况下，完成dp[i]的更新？** 在二维的情况下，确定了当前要考虑物品i，然后从前往后的遍历背包容量，完成更新。 

```java
for(int j=0;j<=bagSize;j++){
    // 读取上一行数据dp[i-1] 从前往后完成对 dp[i]的更新
}
```

在一维的情况下，其实有一个技巧，**那就是从后往前遍历背包容量**，就可以完成更新。这里也很重要，**反过来想，继续保持从前往后更新的话，数据的前半部分其实已经被污染了**，不再是原来的`dp[i-1]`，更新的数据自然是错误的。更现实的意义，就是`dp[j-weight[i]] ` 是不应该考虑物品i的，**否则就会造成物品i的重复放入**，而从前往后更新，会破坏这一点。

```java
for(int i=0;i<items.length;i++){ // 物品 
    for(int j=bagSize;j>=items[i];j--){ // 逆序遍历背包容量
        // 这里将 背包容量与物品重量的比较 放在了for循环的条件里判断 
        // 因为一维的情况下 当背包容量不够存放时 保持上一个状态的数据即可   
        // 二维要写 是因为每一行数据初始化为0 
       dp[j] = max(dp[j],dp[j-weight[i]]+weight[i]);
    }
}
```

**物品和背包容量的遍历顺序是否可以调换呢？答案是不可以！** 上述的推导，已经确定了在一维状态数组的情况下，为了正确更新，背包的遍历只能是从后往前，如果是先容量循环，后物品循环，**则在第一次循环容量为bagsize的情况，事实上只能考虑同时放入一个物品，这是没有意义的。**



为什么物品遍历完，整个算法就可以结束了呢？因为这中间其实拆解了问题，我们考虑物品0-i，然后逐步扩大规模，在迭代过程中，考虑物品i的存放与否，动态更新dp数组。当迭代结束时，就已经将全部物品考虑完毕了。**对比回溯，回溯也有类似的步骤，那就是为了保证有序的考虑情况，存在一个横向遍历。只是，回溯的过程是一棵树，时间复杂度是`m!`，而背包优化了这一点，复杂度为`m*n`，m为物品数量，n为背包容量。**

#### 最大组合数量

背包问题的衍化，容量为j的背包装满最多有几种组合，**是一个组合问题，但不要求具体的组合方案。** 

定义`dp[j]`的为容量为j的背包有`dp[j]`种组合，那么考虑物品i时，它的组合数为`dp[j-weight[i]]*1` ，就是在不考虑该物品的组合数*1。在最大容量的案例下，**用`max()`函数来取舍物品存放与否的结果并更新，而在组合问题上，要选择相加，即`dp[j] =dp[j] + dp[j-weight[i]]*1` ，前者表示不放物品i的组合数，后者是放了以后的组合数，用放和不放来划分两种情况，这也是一个值得注意的地方。**
```java
for(int i=0;i<items.length;i++){ // 物品 
    for(int j=bagSize;j>=items[i];j--){ // 逆序遍历背包容量
		// 要考虑前序状态 
       dp[j] += dp[j-weight[i]];
    }
}
```



#### 最少物品数量 

容量为j的背包装满最少需要多少件物品。 



定义`dp[j]`的为容量为j的背包最少需要dp[j]件数量的物品，那么在考虑物品i时，装满背包的物品数量就是`dp[j-i]+1` ，而`dp[j]=min(dp[j],dp[j-i]+1)`，表示在原有不考虑物品i的方案和考虑物品i的方案中，选取数量小的那一个。

核心思路就是上面这样，只是有一些细节要考虑。当`dp[j]==0`时，其实表示容量j无法装满（除了j=0这种情况）。因此，在初始化的时候，要设置为最大值。 

```java
int[] dp = new dp[size+1];
int max = Integer.MAX_VALUE;
Arrays.fill(dp,max); // 最大值 
dp[0] = 0; // 初始化
```



#### 背包维度 

背包的维度，可能不止一个。一件物品放入背包，定义它在“价值”这个维度上有所影响，当然也可以它对另外一个“维度”也会有影响。

**不同维度的背包，在代码实现上，只要开辟不同数组即可。数组的更新和和遍历顺序，可以简化成一维数组的考虑。**



[一和零](https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html)： 该问题就存在两个维度的背包，一个只有0-1组成的字符串，放进一个背包里，会同时增加0的个数、1的个数，要同时考虑。 





### 完全背包

完全背包，指的就是一件物品，可以重复放入多次。

在0-1背包问题中，为了保证物品不被重复放入，我们从后向前更新dp数组。**而完全背包问题， 恰恰相反，需要从前往后更新数组。**原因如出一辙，只是目的不同。

```java
for(item:items){
    for(int j=0;j<=bagSize;j++){
        // 前面的元素j一旦完成更新 其实就是已经将物品item的存放与否纳入考虑了 
        // 这就保证了物品的可重复放入
    }
}
```

### 遍历顺序

关于背包容量是前向遍历，还是后向遍历，只要考虑物品是否可以重复放入即可。



究竟是先遍历物品，还是先遍历物品，没有定论，要根据具体的场景决定。 **比较精髓的一个结论是，先容量后物品，其实是考虑排列问题，物品的存放顺序不同，会重复计算。而先物品后容量，是一个组合问题，因为遍历的有序性，同一组合只会被计算一次。** 

举一个具体的例子，假设物品为{1,5}，背包容量足够。

```java
// 先容量后物品
for(int j=0;j<=bagSize;j++){
    for(int item:items){
        // 背包j固定 遍历物品item 
    }
}
```

则在“先容量后物品” 的情况下，背包容量为6的情况下，会遍历得到以下顺序：

* `dp[6-1]+5 ==> {5,1}` 
* `dp[6-5]+5 ==> {1,5}`

这是同一个组合，但是是不同排列。 

反之，

```java
// 先容量后物品
for(int item:items){
    for(int j=0;j<=bagSize;j++){
        // 物品固定 考虑背包容量
    }
}
```

在这种情况下，存放顺序的推导如下：

* 考虑物品1，则 `dp[6]:1`
* 考虑物品5，则`dp[6]:1,5` ，

考虑物品i时，如果放入，它的顺序一定在前面已经遍历过的物品的后面，**有点类似于回溯的横向遍历，每次以不同的节点作为开始，来区分不同的组合。**



## 买卖股票

**使用买卖股票的动态规划核心在于设置dp数组。令dp[i]表示第i天的现金，分别用0，1来表示股票的未持有和持有状态下的现金**，则第i天的股票状态可以由i-1天推导可得：

*  持有状态：
  * 原来就持有` dp[i-1][1]`
  * 原来未持有，今天买入，`dp[i-1][0]-prices[i]` ，因为是买入（作为支出），现金减少 
* 未持有状态：
  * 原来就未持有：`dp[i-1][0]`
  * 原来持有，今天卖出： `dp[i-1][1]+prices[i]` ，因为是卖出（作为收入），现金增加 

第0天的dp数组初始化为`dp[0] = new int[]{0,-prices[0]}`，按照上面对dp数组的解释，未持有自然是不买，现金0，持有自然是买入，在卖出前作为负债状态。 

```java
// dp数组推导
for(int i=1;i<prices.length;i++){
    dp[i][0] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]); // 未持有
    dp[i][1] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i]); // 持有
}
return Math.max(dp[prices.length-1][0],dp[prices.length-1][1]); // 取最大值
```



还有很多股票问题的变种，比如限制交易次数、手续费等。就“限制交易次数”这个方面来说，**变化的地方在于要定义多个状态，来进行所有可能的推导。**

例如，限制最多限制交易2次，**虽然股票总是处于持有/未持有两种状态，但仅仅有这两个状态，是不足以分析问题的**。总的状态如下：

1. 初始化：不曾买入，卖出 
2. 第一次买入
3. 第一次卖出
4. 第二次买入
5. 第二次卖出 

**可见，有些状态之间的推导是受限的**，例如，第二次卖出一定是从第二次买入推导而来。总的状态推导如下：

1. 初始化：只有一种可能，沿用原来的初始化 ，`dp[i][0]=dp[i-1][0]`
2. 第一次买入：
   1. 原来就第一次买入：`dp[i][1]=dp[i-1][1]` 
   2. 原来初始化，今天买入：`dp[i][1]=dp[i-1][0]-prices[i]` 
3. 第一次卖出：
   1. 原来就第一次卖出：`dp[i][2]=dp[i-1][2]`
   2. 原来第一次买入，今天卖出：`dp[i][2]=dp[i-1][1]+prices[i]` 
4. 第二次买入：
   1. 原来就第二次买入：`dp[i][3]=dp[i-1][3]` 
   2. 原来第一次卖出，今天买入（所以是第二次）：`dp[i][1]=dp[i-1][3]-prices[i]` 
5. 第二次卖出：
   1. 原来就第二次卖出：`dp[i][4]=dp[i-1][4]`
   2. 原来第二次买入，今天卖出：`dp[i][4]=dp[i-1][3]+prices[i]`  



第0天的初始化：`dp[0]=new int[]{0,-prices[0],0,-prices[0],0}` ，当天买入后再卖出，持有现金还是0。 



总结起来，**股票状态的罗列要考虑当天各种可能的情况。**



## 编辑距离 

可以总结为两个字符串子序列s和t的问题，定义状态数组dp的含义为：`dp[i][j]`表示s[i]结尾的子序列和t[j]结尾的子序列编辑距离的问题。其中，递推公式的推导要把握住当前字符串比较相等与否：

1. `s[i] == t[j]`：如果相等，问题规模一般就缩减为`dp[i-1][j-1]` 
2. `s[i] != t[j]`： 如果不等，则一般要考虑增删改，这中间，删除就是关键一步。怎么模拟删除操作呢？答案就是，用游标回退，比如`s[i-1]`就可以表示不考虑当前`s[i]`的情况。**而增加的思想，来源于这样一个构思：s增加一个字母，就相当于t减少一个字母。**
